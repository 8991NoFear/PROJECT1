package application;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.Optional;

import com.jfoenix.controls.JFXButton;
import com.jfoenix.controls.JFXToggleButton;

import javafx.application.Platform;
import javafx.beans.binding.Bindings;
import javafx.beans.binding.BooleanBinding;
import javafx.beans.binding.DoubleBinding;
import javafx.beans.value.ChangeListener;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.control.ButtonType;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.ScrollPane.ScrollBarPolicy;
import javafx.scene.control.TextInputDialog;
import javafx.scene.control.ToggleGroup;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.text.Text;
import javafx.scene.text.TextFlow;
import javafx.scene.transform.Rotate;

public class SceneController {
	@FXML
	private JFXButton about;
	@FXML
	private JFXButton exit;
	@FXML
	private JFXToggleButton addVertex;
	@FXML
	private ToggleGroup status;
	@FXML
	private JFXToggleButton resetGraph;
	@FXML
	private JFXToggleButton deleteGraph;
	@FXML
	private JFXToggleButton BFS;
	@FXML
	private JFXToggleButton DFS;
	@FXML
	private JFXToggleButton SP;
	@FXML
	private ScrollPane resultPane;
	@FXML
	private TextFlow resultText;
	@FXML
	private Pane drawingPlace;
	
	/*
	 * Special Global Variables
	 * */
	
	private LinkedList<Vertex> header;
	private Integer vertexIndex;
	private Vertex start;
	private Vertex end;
	private Line line;
    private double sceneX, sceneY, layoutX, layoutY;
    private Algorithms alg;
    
 // Initialization
 	@FXML
 	private void initialize() {
 		header = new LinkedList<Vertex>();
 		vertexIndex = 0;
 		start = null;
 		end = null;
 		sceneX = 0.0d;
 		sceneY = 0.0d;
 		layoutX = 0.0;
 		layoutY = 0.0d;
 		
 		line = new Line();
 		line.setStrokeWidth(3);
 		line.setStroke(Color.ORANGE);
 		line.setFill(Color.ORANGE);
 		
 		alg = new Algorithms(this);
 	}
 	
    public TextFlow getResultText() {
		return resultText;
	}

	public LinkedList<Vertex> getHeader() {
		return header;
	}

	public void disableAllJFXToggleButton() {
    	addVertex.setDisable(true);
		resetGraph.setDisable(true);
		deleteGraph.setDisable(true);
		BFS.setDisable(true);
		DFS.setDisable(true);
		SP.setDisable(true);
    }
    
    public void enableAllJFXToggleButton() {
    	addVertex.setDisable(false);
		resetGraph.setDisable(false);
		deleteGraph.setDisable(false);
		BFS.setDisable(false);
		DFS.setDisable(false);
		SP.setDisable(false);
    }
    
	public void unselectedAllJFXToggleButton() {
		addVertex.setSelected(false);
		resetGraph.setSelected(false);
		deleteGraph.setSelected(false);
		BFS.setSelected(false);
		DFS.setSelected(false);
		SP.setSelected(false);
	}
	
	// Event Listener on JFXButton[#about].onMouseClicked
	@FXML
	private void aboutHandler(MouseEvent event) {
		
		// TODO Autogenerated
		
	}
	
	// Event Listener on JFXButton[#exit].onMouseClicked
	@FXML
	private void exitHandler(MouseEvent event) {
		
		Platform.exit();
		
	}
	
	// Event Listener on JFXToggleButton[#addVertex].onMouseClicked
	@FXML
	private void addVertexHandler(MouseEvent event) {
		
		// TODO Autogenerated
		
	}
	
	// Event Listener on JFXToggleButton[#resetGraph].onMouseClicked
	@FXML
	private void resetGraphHandler(MouseEvent event) {
		
		if(resetGraph.isSelected()) {
			alg.resetGraph();
		}
		
	}
	
	// Event Listener on JFXToggleButton[#deleteGraph].onMouseClicked
	@FXML
	private void deleteGraphHandler(MouseEvent event) {
		
		if(deleteGraph.isSelected()) {
			Alert alert = alert(AlertType.CONFIRMATION, "Confirmation", null, "Are you sure to delete graph");
			Optional<ButtonType> result = alert.showAndWait();
			if(result.get() == ButtonType.OK) {
				vertexIndex = 0;
				header.clear();
				drawingPlace.getChildren().clear();
			} else {
				deleteGraph.setSelected(false);
			}
		}
		
	}
	
	// Event Listener on JFXToggleButton[#BFS].onMouseClicked
	@FXML
	private void BFSHandler(MouseEvent event) {

		if(BFS.isSelected()) {
			if(!header.isEmpty()) {
				alg.BFSGraph();
			} else {
				BFS.setSelected(false);
				Alert alert = alert(AlertType.ERROR, "error", "Can not traveling graph", "you don't have any graph to travel!");
				alert.showAndWait();
			}
		}
		
	}
	
	// Event Listener on JFXToggleButton[#DFS].onMouseClicked
	@FXML
	private void DFSHandler(MouseEvent event) {
		
		if(DFS.isSelected()) {
			if(!header.isEmpty()) {
				alg.BFSGraph();
			} else {
				DFS.setSelected(false);
				Alert alert = alert(AlertType.ERROR, "error", "Can not traveling graph", "you don't have any graph to travel!");
				alert.showAndWait();
			}
		}
		
	}
	
	// Event Listener on JFXToggleButton[#SP].onMouseClicked
	@FXML
	private void SPHandler(MouseEvent event) {
		
		if(SP.isSelected()) {
			if(!header.isEmpty()) {
				Vertex source = getSource();
				if(source != null) {
					alg.dijkstra(source);
				} else {
					SP.setSelected(false);
					Alert alert = alert(AlertType.ERROR, "error", "Can not find shortest path on graph", "Can not find specific source vertex!");
					alert.showAndWait();
				}
			} else {
				SP.setSelected(false);
				Alert alert = alert(AlertType.ERROR, "error", "Can not find shortest path on graph", "you don't have any graph to find shortest path!");
				alert.showAndWait();
			}
		}
		
	}
	
	private Vertex getSource() {
		TextInputDialog tid = textInputDialog("Confirmation", "Enter the source vertex", "Source");
		Optional<String> res = tid.showAndWait();
		if(res.isPresent()) {
			String nameID = res.get();
			for(Vertex vtx: header) {
				if(vtx.getNameID().equals(nameID)) {
					return vtx;
				}
			}
		}
		return null;
	}
	
	// Event Listener on AnchorPane[#drawingPlace].onMouseClicked
	@FXML
	private void drawHandler(MouseEvent event) {
		
		//Click outside to cancel add edge
		if(start != null) {
			start.getDot().getChildren().get(0).setStyle("-fx-fill: black");
			start = null;
		}
		
		//Click outside to add vertex
		if(addVertex.isSelected() && (event.getButton() == MouseButton.PRIMARY)) {
			vertexIndex++;
			Vertex vtx = new Vertex(vertexIndex.toString());
			StackPane dot = getDot(vertexIndex.toString());
			dot.setLayoutX(event.getX());
			dot.setLayoutY(event.getY());
			drawingPlace.getChildren().add(dot);
			dot.addEventHandler(MouseEvent.MOUSE_CLICKED, new addEdgeHandler(vtx));
			vtx.setDot(dot);
			setRightMenuForVertex(vtx);
			header.add(vtx);
		}
		
	}
	
	private TextInputDialog textInputDialog(String title, String header, String content) {
		TextInputDialog tid = new TextInputDialog();
		tid.setTitle(title);
		tid.setHeaderText(header);
		tid.setContentText(content);
		tid.initOwner(Main.getPrimaryStage());
		return tid;
	}
	
	private Alert alert(AlertType type, String title, String header, String content) {
		Alert alert = new Alert(type);
		alert.setTitle(title);
		alert.setHeaderText(header);
		alert.setContentText(content);
		alert.initOwner(Main.getPrimaryStage());
		return alert;
	}
	
	private boolean hasEdge(Vertex start, Vertex end) {
		Iterator<Edge> iter = start.getAdj().iterator();
		while(iter.hasNext()){
			Edge edge = iter.next();
			if(edge.getEnd().equals(end)) {
				return true;
			}
		}
		
		return false;
	}
	
	private Edge getEdge(Vertex start, Vertex end) {
		Iterator<Edge> iter = start.getAdj().iterator();
		while(iter.hasNext()){
			Edge edge = iter.next();
			if(edge.getEnd().equals(end)) {
				return edge;
			}
		}
		
		return null;
	}
	
	private void setRightMenuForVertex(Vertex vtx) {
		ContextMenu menu = new ContextMenu();
		MenuItem item1 = new MenuItem("Add edge");
		MenuItem item2 = new MenuItem("ChangeID");
		MenuItem item3 = new MenuItem("Delete");
		menu.getItems().addAll(item1, item2, item3);
		
		StackPane dot = vtx.getDot();
		
		item1.setOnAction(new EventHandler<ActionEvent>() {

			@Override
			public void handle(ActionEvent event) {
				
				if(start != null) {
					start.getDot().getChildren().get(0).setStyle("-fx-fill: black");
				}
				start = vtx;
				start.getDot().getChildren().get(0).setStyle("-fx-fill: orange");
				
			}
		});
		
		item2.setOnAction(new EventHandler<ActionEvent>() {

			@Override
			public void handle(ActionEvent event) {
				TextInputDialog dialog = textInputDialog("Change nameID", "Change nameID for this vertex", "New nameID");
				Optional<String> result = dialog.showAndWait();
				if(result.isPresent()) {
					if((!result.get().equals(""))) {
						vtx.setNameID(result.get());
						Label label = (Label) dot.getChildren().get(1);
						label.setText(result.get());
					} else {
						Alert alert = alert(AlertType.ERROR, "Change ID Error", "Can not change ID", "You have not given any ID!");
						alert.showAndWait();
					}
				}
			}
			
		});
		
		item3.setOnAction(new EventHandler<ActionEvent>() {

			@Override
			public void handle(ActionEvent event) {
				LinkedList<Edge> adj = vtx.getAdj();
				LinkedList<Edge> reAdj = vtx.getReAdj();
				Iterator<Edge> adjIter = adj.iterator();
				Iterator<Edge> reAdjIter = reAdj.iterator();
				
				while(adjIter.hasNext()) {
					Edge edge = adjIter.next();
					edge.getEnd().getReAdj().remove(edge);
					drawingPlace.getChildren().removeAll(edge.getObsList());
				}
				
				while(reAdjIter.hasNext()) {
					Edge edge = reAdjIter.next();
					edge.getStart().getAdj().remove(edge);
					drawingPlace.getChildren().removeAll(edge.getObsList());
				}
				
				adj.removeAll(adj);
				reAdj.removeAll(reAdj);
				header.remove(vtx);
				drawingPlace.getChildren().remove(dot);
			}
			
		});
		
		dot.setOnContextMenuRequested(new EventHandler<ContextMenuEvent>() {

			@Override
			public void handle(ContextMenuEvent e) {
				unselectedAllJFXToggleButton();
				menu.show(dot, e.getScreenX(), e.getScreenY());
			}
			
		});
	}
	
	private void setRightMenuForEdge(Edge edge) {
		ContextMenu menu = new ContextMenu();
		MenuItem item1 = new MenuItem("Change weight");
		MenuItem item2 = new MenuItem("Delete");
		menu.getItems().addAll(item1, item2);
		
		item1.setOnAction(new EventHandler<ActionEvent>() {

			@Override
			public void handle(ActionEvent event) {
				try {
					TextInputDialog dialog = textInputDialog("Change weight", "Change weight for this Edge", "New weight");
					Optional<String> result = dialog.showAndWait();
					if(result.isPresent()) {
						edge.setWeight(Integer.valueOf(result.get()));
						StackPane label = edge.getWgtLabel();
						Text txtLabel = (Text) label.getChildren().get(0);
						txtLabel.setText(result.get());
					}
				} catch (NumberFormatException ex) {
					Alert alert = alert(AlertType.ERROR, "Change Weight Error", "Can not change weight", "Can not change weight with the weight you give!");
					alert.showAndWait();
				}
			}
			
		});
		
		item2.setOnAction(new EventHandler<ActionEvent>() {

			@Override
			public void handle(ActionEvent event) {
				edge.getStart().getAdj().remove(edge);
				edge.getEnd().getReAdj().remove(edge);
				drawingPlace.getChildren().removeAll(edge.getObsList());
			}
			
		});
		
		edge.getWgtLabel().setOnContextMenuRequested(new EventHandler<ContextMenuEvent>() {

			@Override
			public void handle(ContextMenuEvent e) {
				menu.show(edge.getWgtLabel(), e.getScreenX(), e.getScreenY());
			}
			
		});
	}
	
	private void buildSingleDirectionalLine(StackPane startDot, StackPane endDot, String text, Edge edge) {
        Line lineAB = getLine(startDot, endDot);
        StackPane arrowAB = getArrow(lineAB, startDot, endDot, true, false);
        StackPane weightAB = getWeight(lineAB, text);
        edge.setObsList(lineAB, weightAB, arrowAB);
		setRightMenuForEdge(edge);
        drawingPlace.getChildren().addAll(edge.getObsList());
    }

	private void buildBiDirectionalLine(boolean isEnd, StackPane startDot, StackPane endDot, String text, Edge edge) {
        Line virtualCenterLine = getLine(startDot, endDot);
        virtualCenterLine.setOpacity(0);
        StackPane centerLineArrowAB = getArrow(virtualCenterLine, startDot, endDot, true, true);
        centerLineArrowAB.setOpacity(0);
        StackPane centerLineArrowBA = getArrow(virtualCenterLine, startDot, endDot, false, true);
        centerLineArrowBA.setOpacity(0);

        Line directedLine = new Line();
        directedLine.setStroke(Color.BLACK);
        directedLine.setStrokeWidth(2);

        double diff = isEnd ? -centerLineArrowAB.getPrefWidth() : centerLineArrowAB.getPrefWidth();
        final ChangeListener<Number> listener = (obs, old, newVal) -> {
            Rotate r1 = new Rotate();
            r1.setPivotX(virtualCenterLine.getStartX());
            r1.setPivotY(virtualCenterLine.getStartY());
            r1.setAngle(centerLineArrowAB.getRotate());
            Point2D point = r1.transform(new Point2D(virtualCenterLine.getStartX(), virtualCenterLine.getStartY() + diff));
            directedLine.setStartX(point.getX());
            directedLine.setStartY(point.getY());

            Rotate r2 = new Rotate();
            r2.setPivotX(virtualCenterLine.getEndX());
            r2.setPivotY(virtualCenterLine.getEndY());
            r2.setAngle(centerLineArrowBA.getRotate());
            Point2D point2 = r2.transform(new Point2D(virtualCenterLine.getEndX(), virtualCenterLine.getEndY() - diff));
            directedLine.setEndX(point2.getX());
            directedLine.setEndY(point2.getY());
        };
        centerLineArrowAB.rotateProperty().addListener(listener);
        centerLineArrowBA.rotateProperty().addListener(listener);
        virtualCenterLine.startXProperty().addListener(listener);
        virtualCenterLine.startYProperty().addListener(listener);
        virtualCenterLine.endXProperty().addListener(listener);
        virtualCenterLine.endYProperty().addListener(listener);
        startDot.setLayoutX(startDot.getLayoutX() + 0.1);
        startDot.setLayoutY(startDot.getLayoutY() + 0.1);
        
        StackPane mainArrow = getArrow(directedLine, startDot, endDot, isEnd, true);
        StackPane wgtLabel = getWeight(directedLine, text);
        edge.setObsList(directedLine, wgtLabel, mainArrow);
        setRightMenuForEdge(edge);
        drawingPlace.getChildren().addAll(edge.getObsList());
    }
    
	private Line getLine(StackPane startDot, StackPane endDot) {
        Line line = new Line();
        line.setStroke(Color.BLACK);
        line.setStrokeWidth(2);
        line.startXProperty().bind(startDot.layoutXProperty().add(startDot.translateXProperty()).add(startDot.widthProperty().divide(2)));
        line.startYProperty().bind(startDot.layoutYProperty().add(startDot.translateYProperty()).add(startDot.heightProperty().divide(2)));
        line.endXProperty().bind(endDot.layoutXProperty().add(endDot.translateXProperty()).add(endDot.widthProperty().divide(2)));
        line.endYProperty().bind(endDot.layoutYProperty().add(endDot.translateYProperty()).add(endDot.heightProperty().divide(2)));
        return line;
    }
    
	private StackPane getArrow(Line line, StackPane startDot, StackPane endDot, boolean toLineEnd, boolean forDoubleEdge) {
        double size = 13; // Arrow size
        
        StackPane arrow = new StackPane();
        arrow.setStyle("-fx-background-color:black;-fx-shape: \"M0,-4L4,0L0,4Z\"");
        arrow.setPrefSize(size, size);
        arrow.setMaxSize(size, size);
        arrow.setMinSize(size, size);

        // Determining the arrow visibility unless there is enough space between dots.
        DoubleBinding xDiff = line.endXProperty().subtract(line.startXProperty());
        DoubleBinding yDiff = line.endYProperty().subtract(line.startYProperty());
        BooleanBinding visible = (xDiff.lessThanOrEqualTo(size).and(xDiff.greaterThanOrEqualTo(-size)).and(yDiff.greaterThanOrEqualTo(-size)).and(yDiff.lessThanOrEqualTo(size))).not();
        arrow.visibleProperty().bind(visible);
        
        // Determining the x point on the line which is at a certain distance.
        DoubleBinding tX = Bindings.createDoubleBinding(() -> {
            double xDiffSqu = (line.getEndX() - line.getStartX()) * (line.getEndX() - line.getStartX());
            double yDiffSqu = (line.getEndY() - line.getStartY()) * (line.getEndY() - line.getStartY());
            double lineLength = Math.sqrt(xDiffSqu + yDiffSqu);
            double dt;
            double delta = 0;
            if(forDoubleEdge) {
            	delta = 8;
            }
            if (toLineEnd) {
                // When determining the point towards end, the required distance is total length minus (radius + arrow half width)
                dt = delta + lineLength - (endDot.getWidth() / 2) - (arrow.getWidth() / 2);
            } else {
                // When determining the point towards start, the required distance is just (radius + arrow half width)
                dt = - delta + (startDot.getWidth() / 2) + (arrow.getWidth() / 2);
            }

            double t = dt / lineLength;
            double dx = ((1 - t) * line.getStartX()) + (t * line.getEndX());
            return dx;
        }, line.startXProperty(), line.endXProperty(), line.startYProperty(), line.endYProperty());

        // Determining the y point on the line which is at a certain distance.
        DoubleBinding tY = Bindings.createDoubleBinding(() -> {
            double xDiffSqu = (line.getEndX() - line.getStartX()) * (line.getEndX() - line.getStartX());
            double yDiffSqu = (line.getEndY() - line.getStartY()) * (line.getEndY() - line.getStartY());
            double lineLength = Math.sqrt(xDiffSqu + yDiffSqu);
            double dt;
            double delta = 0;
            if(forDoubleEdge) {
            	delta = 8;
            }
            if (toLineEnd) {
                dt = delta + lineLength - (endDot.getHeight() / 2) - (arrow.getHeight() / 2);
            } else {
                dt = - delta + (startDot.getHeight() / 2) + (arrow.getHeight() / 2);
            }
            double t = dt / lineLength;
            double dy = ((1 - t) * line.getStartY()) + (t * line.getEndY());
            return dy;
        }, line.startXProperty(), line.endXProperty(), line.startYProperty(), line.endYProperty());

        arrow.layoutXProperty().bind(tX.subtract(arrow.widthProperty().divide(2)));
        arrow.layoutYProperty().bind(tY.subtract(arrow.heightProperty().divide(2)));

        DoubleBinding endArrowAngle = Bindings.createDoubleBinding(() -> {
            double stX = toLineEnd ? line.getStartX() : line.getEndX();
            double stY = toLineEnd ? line.getStartY() : line.getEndY();
            double enX = toLineEnd ? line.getEndX() : line.getStartX();
            double enY = toLineEnd ? line.getEndY() : line.getStartY();
            double angle = Math.toDegrees(Math.atan2(enY - stY, enX - stX));
            if (angle < 0) {
                angle += 360;
            }
            return angle;
        }, line.startXProperty(), line.endXProperty(), line.startYProperty(), line.endYProperty());
        arrow.rotateProperty().bind(endArrowAngle);

        return arrow;
    }

	private StackPane getWeight(Line line, String weightLabel) {
        double size = 25;
        StackPane weight = new StackPane();
        weight.setStyle("-fx-background-color:silver;-fx-border-width:1px;-fx-border-color:black;");
        weight.setPrefSize(size, size);
        weight.setMaxSize(size, size);
        weight.setMinSize(size, size);

        DoubleBinding wgtSqrHalfWidth = weight.widthProperty().divide(2);
        DoubleBinding wgtSqrHalfHeight = weight.heightProperty().divide(2);
        DoubleBinding lineXHalfLength = line.endXProperty().subtract(line.startXProperty()).divide(2);
        DoubleBinding lineYHalfLength = line.endYProperty().subtract(line.startYProperty()).divide(2);

        weight.layoutXProperty().bind(line.startXProperty().add(lineXHalfLength.subtract(wgtSqrHalfWidth)));
        weight.layoutYProperty().bind(line.startYProperty().add(lineYHalfLength.subtract(wgtSqrHalfHeight)));
        
        Text text = new Text(weightLabel);
        text.setFill(Color.BLACK);
        weight.getChildren().add(text);
        
        return weight;
    }

	private StackPane getDot(String text) {
        double radius = 15;
        double paneSize = 2 * radius;
        
        Circle dot = new Circle();
        dot.setRadius(radius);
        dot.setStyle("-fx-fill: black");

        Label txt = new Label(text);
        txt.setStyle("-fx-font-size:18px;-fx-font-weight:bold;");
        txt.setTextFill(Color.WHITE);
        
        StackPane dotPane = new StackPane();
        dotPane.getChildren().addAll(dot, txt);
        dotPane.setPrefSize(paneSize, paneSize);
        dotPane.setMaxSize(paneSize, paneSize);
        dotPane.setMinSize(paneSize, paneSize);
        dotPane.setOnMousePressed(e -> {
            sceneX = e.getSceneX();
            sceneY = e.getSceneY();
            layoutX = dotPane.getLayoutX();
            layoutY = dotPane.getLayoutY();
        });
        dotPane.setOnMouseDragged(e -> {
        	// Offset of drag
            double offsetX = e.getSceneX() - sceneX;
            double offsetY = e.getSceneY() - sceneY;

            // Taking parent bounds
            Bounds parentBounds = dotPane.getParent().getLayoutBounds();

            // Drag node bounds
            double currPaneLayoutX = dotPane.getLayoutX();
            double currPaneWidth = dotPane.getWidth();
            double currPaneLayoutY = dotPane.getLayoutY();
            double currPaneHeight = dotPane.getHeight();

            if ((currPaneLayoutX + offsetX < parentBounds.getWidth() - currPaneWidth) && (currPaneLayoutX + offsetX > -1)) {
                dotPane.setTranslateX(offsetX);
            } else if (currPaneLayoutX + offsetX < 0) {
                dotPane.setTranslateX(-currPaneLayoutX);
            } else {
                dotPane.setTranslateX(parentBounds.getWidth() - currPaneLayoutX - currPaneWidth);
            }

            if ((currPaneLayoutY + offsetY < parentBounds.getHeight() - currPaneHeight) && (currPaneLayoutY + offsetY > -1)) {
                dotPane.setTranslateY(offsetY);
            } else if (currPaneLayoutY + offsetY < 0) {
                dotPane.setTranslateY(-currPaneLayoutY);
            } else {
                dotPane.setTranslateY(parentBounds.getHeight() - currPaneLayoutY - currPaneHeight);
            }
        });
        dotPane.setOnMouseReleased(e -> {
            // Updating the new layout positions
            dotPane.setLayoutX(layoutX + dotPane.getTranslateX());
            dotPane.setLayoutY(layoutY + dotPane.getTranslateY());

            // Resetting the translate positions
            dotPane.setTranslateX(0);
            dotPane.setTranslateY(0);
        });
        
        return dotPane;
    }
	
	private class addEdgeHandler implements EventHandler<MouseEvent>{
		Vertex vtx;
		
		public addEdgeHandler(Vertex vtx) {
			this.vtx = vtx;
		}
		
		@Override
		public void handle(MouseEvent event) {
			if ((start != null) && (event.getButton() == MouseButton.PRIMARY)) {
				end = vtx;
				start.getDot().getChildren().get(0).setStyle("-fx-fill: black");
				
				try {
					if(start.equals(end)) {
						Alert alert = alert(AlertType.ERROR, "Adding Edge Error", "Can not add edge", "Start Vertex and End Vertex must be different!");
						alert.showAndWait();
					} else if(hasEdge(start, end)) {
						Alert alert = alert(AlertType.ERROR, "Adding Edge Error", "Can not add edge", "The edge is already exist!");
						alert.showAndWait();
					} else if(hasEdge(end, start)){
						// Add edge from start to end when already have a edge from end to start
						Edge endToStart = getEdge(end, start);
						TextInputDialog dialog = textInputDialog("Confirmation", "Enter the weight for this Edge", "Weight");
						Optional<String> result = dialog.showAndWait();
						if (result.isPresent()) {
							Integer wgt = Integer.parseInt(result.get());
							wgt = wgt > 0 ? wgt : - wgt;
							
							Edge newEdge = new Edge(start, end, wgt);
							Edge oldEdge = new Edge(end, start, endToStart.getWeight());
							start.getAdj().add(newEdge);
							end.getReAdj().add(newEdge);
							start.getReAdj().add(oldEdge);
							end.getAdj().add(oldEdge);
							
							endToStart.getStart().getAdj().remove(endToStart);
							endToStart.getEnd().getReAdj().remove(endToStart);
							drawingPlace.getChildren().removeAll(start.getDot(), end.getDot());
							drawingPlace.getChildren().removeAll(endToStart.getObsList());
							buildBiDirectionalLine(true, start.getDot(), end.getDot(), wgt.toString(), newEdge);
							buildBiDirectionalLine(false, start.getDot(), end.getDot(), ((Integer)endToStart.getWeight()).toString(), oldEdge);
							drawingPlace.getChildren().addAll(start.getDot(), end.getDot());
						}
					} else {
						// Add edge from start to end the first time
						TextInputDialog dialog = textInputDialog("Confirmation", "Enter the weight for this Edge", "Weight");
						Optional<String> result = dialog.showAndWait();
						if (result.isPresent()) {
							Integer wgt = Integer.parseInt(result.get());
							wgt = wgt > 0 ? wgt : - wgt;
							
							Edge edge = new Edge(start, end, wgt);
							start.getAdj().add(edge);
							end.getReAdj().add(edge);
							
							drawingPlace.getChildren().removeAll(start.getDot(), end.getDot());
							buildSingleDirectionalLine(start.getDot(), end.getDot(), wgt.toString(), edge);
							drawingPlace.getChildren().addAll(start.getDot(), end.getDot());
						}
					}
				} catch (NumberFormatException ex) {
					Alert alert = alert(AlertType.ERROR, "Add Edge Error", "Can not add edge", "Can not add edge with the weight you give!");
					alert.showAndWait();
				}
				
				start = null;
				end = null;
			}
		}
	}
}
